Perfect ğŸ”¥
Below is your combined â€œLCA (Lowest Common Ancestor)â€ GitHub-style revision sheet â€” covering both BST (Leetcode 235) and Binary Tree (Leetcode 236) â€” crafted exactly like Striver-style notes + FAANG/Nutanix interview expectations.

ğŸŒ³ Lowest Common Ancestor â€” Complete Interview Sheet

(For BST & Binary Tree)

ğŸ§© 1ï¸âƒ£ LCA in a Binary Search Tree

Leetcode 235. Lowest Common Ancestor of a BST

ğŸ”¹ Intuition

BST has an ordered structure:

Left subtree â†’ smaller values

Right subtree â†’ larger values

So:

If both p and q are smaller than root â†’ go left

If both are greater â†’ go right

Otherwise, current node is the split point â†’ LCA

ğŸ”¹ Recursive Solution
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root) return nullptr;

        if (p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);

        if (p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);

        return root;  // Split point found
    }
};

ğŸ”¹ Iterative Solution
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while (root) {
            if (p->val < root->val && q->val < root->val)
                root = root->left;
            else if (p->val > root->val && q->val > root->val)
                root = root->right;
            else
                return root; // Split point
        }
        return nullptr;
    }
};

ğŸ”¹ Complexity
Time	Space
O(h)	O(1) iterative / O(h) recursive
ğŸ”¹ Dry Run Example
BST:     6
        / \
       2   8
      / \ / \
     0  4 7  9
       / \
      3  5

p=2, q=8 â†’ split at 6 â†’ LCA = 6  
p=2, q=4 â†’ split at 2 â†’ LCA = 2

âœ… Pattern Recap (BST)
Condition	Move
p,q < root	root = root->left
p,q > root	root = root->right
Else	root is LCA
ğŸ’¡ Interview Tips

Always confirm â€œBSTâ€ before using < and >.

Easy to confuse with Binary Tree version.

O(h) single-path traversal â†’ super efficient.

ğŸ§© 2ï¸âƒ£ LCA in a Binary Tree

Leetcode 236. Lowest Common Ancestor of a Binary Tree

ğŸ”¹ Intuition

No BST property â†’ must explore entire tree.
We use post-order traversal (Left â†’ Right â†’ Node).

At each node:

If p and q lie on different sides â†’ this node is LCA.

If current node is one of them â†’ current node might be LCA.

ğŸ”¹ Recursive Solution (Most Common in Interviews)
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // Base condition
        if (!root || root == p || root == q)
            return root;

        // Search in subtrees
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        // If both left and right return non-null â†’ current node is LCA
        if (left && right) return root;

        // Otherwise, return whichever side is non-null
        return left ? left : right;
    }
};

ğŸ”¹ Iterative (Parent Map) Version
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        unordered_map<TreeNode*, TreeNode*> parent;
        queue<TreeNode*> qn;
        qn.push(root);
        parent[root] = nullptr;

        // Step 1: Build parent map
        while (!parent.count(p) || !parent.count(q)) {
            TreeNode* node = qn.front();
            qn.pop();

            if (node->left) {
                parent[node->left] = node;
                qn.push(node->left);
            }
            if (node->right) {
                parent[node->right] = node;
                qn.push(node->right);
            }
        }

        // Step 2: Store ancestors of p
        unordered_set<TreeNode*> ancestors;
        while (p) {
            ancestors.insert(p);
            p = parent[p];
        }

        // Step 3: Move upward from q until we hit a common ancestor
        while (!ancestors.count(q))
            q = parent[q];

        return q;
    }
};

ğŸ”¹ Complexity
Time	Space
O(N)	O(H) recursion / O(N) iterative
ğŸ”¹ Debugging Dry Run

Example:

         3
        / \
       5   1
      / \ / \
     6  2 0  8
       / \
      7  4

Case	Input	Output	Explanation
1	p=5, q=1	3	Split at 3
2	p=6, q=4	5	Both in left subtree
3	p=5, q=4	5	One node is ancestor
4	p=5, q=10	null	One node missing (handle separately)
âš ï¸ Edge Case Handling

Add find(root, p) and find(root, q) to ensure both nodes exist:

bool exists(TreeNode* root, TreeNode* x) {
    if (!root) return false;
    if (root == x) return true;
    return exists(root->left, x) || exists(root->right, x);
}


Then only return LCA if both exist.

ğŸ’¡ Key Observations
Concept	Insight
Traversal Type	Post-order
Base Case	if (!root
Split Detection	left && right != null
Ancestor Case	if root == p && q in subtree â†’ LCA = p
Depth Safety	Use iterative parent map for deep trees
ğŸ§  Combined Comparison
Feature	BST (235)	Binary Tree (236)
Uses value ordering	âœ… Yes	âŒ No
Traversal direction	Guided	Full traversal
Time Complexity	O(h)	O(n)
Space Complexity	O(1)	O(h)
Split logic	Value-based	Subtree-based
Edge Cases	Simple	Ancestor, missing node, deep tree
Template Type	Iterative/Recursive	Post-order recursive
ğŸ§® Common Patterns and Variations
Variation	Approach
LCA in BST	Use < and > property
LCA in Binary Tree	DFS post-order
LCA when nodes may not exist	Add existence check
Distance between two nodes	dist(p,q) = depth(p)+depth(q)-2*depth(LCA)
LCA in N-ary tree	Parent Map + Set
LCA in DAG / Graph	Tarjanâ€™s offline LCA (Union-Find)
ğŸ§© Reusable Template Snippet
TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || root == p || root == q) return root;
    TreeNode* left = LCA(root->left, p, q);
    TreeNode* right = LCA(root->right, p, q);
    if (left && right) return root;
    return left ? left : right;
}


âœ… Works for Binary Tree
For BST, just change the logic to value comparison.

ğŸ’ Final Interview Takeaways
ğŸ§  â€œThink before codingâ€

Ask: Is it a BST or just a Binary Tree?

Use BST property only if guaranteed.

ğŸ§± â€œBase condition correctnessâ€

if (!root || root == p || root == q) return root;
This line avoids missing the ancestor scenario.

ğŸ§— â€œDepth handlingâ€

Recursive â†’ elegant but stack-heavy

Parent-map â†’ better for iterative or large trees

ğŸ§© â€œPattern youâ€™ll reuseâ€

Post-order recursion + return non-null child = core pattern for tree-based questions.

ğŸ§¾ Recommended Revision Order

235 â€” LCA in BST

236 â€” LCA in Binary Tree

Edge Case: Ancestor node

Distance between two nodes using LCA

LCA with missing nodes

Iterative + Parent Map versions
