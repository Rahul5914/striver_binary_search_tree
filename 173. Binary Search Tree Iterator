letâ€™s tackle Leetcode 173: Binary Search Tree Iterator â€” one of the most elegant BST problems often discussed in Nutanix, Uber, and Google interviews because it tests your:

Understanding of BST in-order traversal

Ability to convert recursion into iteration using a stack

Design skills (implementing an efficient class with amortized O(1) next operations)

ğŸ¯ Problem Statement
Design an iterator over a binary search tree (BST). Your iterator should be initialized with the root node of a BST.

next() returns the next smallest number in the BST.

hasNext() returns whether there is a next number.

Leetcode Signature:

cpp
Copy code
class BSTIterator {
public:
    BSTIterator(TreeNode* root);
    int next();
    bool hasNext();
};
ğŸ§  Interview Setup (Dialogue Style)
Interviewer:
Can you explain what â€œnext smallest numberâ€ means in the context of a BST?

Candidate (You):
Yes â€” since the BST property ensures left < root < right, the â€œnext smallestâ€ element comes in in-order traversal order.
So, the sequence of next() calls should output an in-order traversal of the BST.

ğŸ” Step 1: Brute Force (Recursive Inorder)
Candidate:
The simplest approach is to do an in-order traversal once, store all elements in a vector, and then use an index to return elements one by one.

But interviewer might ask:

Whatâ€™s the drawback?

âœ… Simple but âŒ not memory-efficient â€” because it stores all nodes (O(N)), and not lazy (we precompute everything).

Brute Force Code
cpp
Copy code
class BSTIterator {
private:
    vector<int> inorder;
    int index;

    void inorderTraversal(TreeNode* root) {
        if (!root) return;
        inorderTraversal(root->left);
        inorder.push_back(root->val);
        inorderTraversal(root->right);
    }

public:
    BSTIterator(TreeNode* root) {
        inorderTraversal(root);
        index = 0;
    }

    int next() {
        return inorder[index++];
    }

    bool hasNext() {
        return index < inorder.size();
    }
};
Time Complexity: O(N) for traversal + O(1) per query

Space Complexity: O(N) for storing traversal

âŒ Not optimal.

ğŸš€ Step 2: Optimized Iterative Approach (Using Stack)
Interviewer:
Can we do this more efficiently â€” maybe without storing the entire traversal?

Candidate:
Yes! We can simulate the recursion using a stack to get elements on demand, achieving O(h) space instead of O(N), where h = height of BST.

ğŸ§© Key Idea
We only push left nodes into the stack until we reach the smallest element.
When we call next():

Pop the top element (thatâ€™s the next smallest).

If the popped node has a right child, push all its left descendants.

Step-by-Step Dry Run
For BST:

markdown
Copy code
        7
       / \
      3   15
          / \
         9  20
Stack building:

Start with pushing all left nodes from root â†’ [7, 3]
Stack (top): 3 â†’ 7

next() â†’ pop 3, result = 3
Push 3â€™s right (none)

next() â†’ pop 7, result = 7
Push right subtreeâ€™s left path: [15, 9]

Stack (top): 9 â†’ 15

â€¦and so on.

âœ… Optimized Code (Interview Ready)
cpp
Copy code
class BSTIterator {
private:
    stack<TreeNode*> st;

    // Helper: push all left nodes
    void pushLeft(TreeNode* node) {
        while (node) {
            st.push(node);
            node = node->left;
        }
    }

public:
    BSTIterator(TreeNode* root) {
        pushLeft(root);
    }

    int next() {
        TreeNode* node = st.top();
        st.pop();
        // If there's a right child, push its entire left path
        pushLeft(node->right);
        return node->val;
    }

    bool hasNext() {
        return !st.empty();
    }
};
ğŸ§® Complexity Analysis
Operation	Time Complexity	Space Complexity
next()	Amortized O(1)	O(h)
hasNext()	O(1)	O(h)
Initialization	O(h)	O(h)

Amortized O(1):
Each node is pushed and popped exactly once â†’ total O(N) for N calls â†’ O(1) per call on average.

ğŸ’¡ Pattern Recognition & Interview Tricks
Pattern	Explanation
Lazy traversal	Donâ€™t compute all results at once; simulate recursion with stack
In-order traversal simulation	Stack stores path of left nodes
Amortized Analysis	Each element is visited once â€” a common trick in â€œiteratorâ€ design questions

âš™ï¸ Common Follow-up Questions
1ï¸âƒ£ How would you implement a reverse iterator (next largest)?
â†’ Push right nodes first, then go left after popping.

2ï¸âƒ£ What if we also need prev() operation?
â†’ Maintain a doubly linked in-order sequence or use two stacks (forward/backward).

3ï¸âƒ£ Can we do it with O(1) space?
â†’ Yes, using Morris Traversal, but that modifies the tree (not allowed usually).

ğŸ§© Reusable Template for Any Tree Iterator
cpp
Copy code
class TreeIterator {
private:
    stack<TreeNode*> st;
    bool reverse; // false = ascending, true = descending

    void pushAll(TreeNode* node) {
        while (node) {
            st.push(node);
            node = reverse ? node->right : node->left;
        }
    }

public:
    TreeIterator(TreeNode* root, bool isReverse) {
        reverse = isReverse;
        pushAll(root);
    }

    int next() {
        TreeNode* node = st.top(); st.pop();
        if (!reverse) pushAll(node->right);
        else pushAll(node->left);
        return node->val;
    }

    bool hasNext() {
        return !st.empty();
    }
};
âœ… Reusable for:

BST Iterator

Two-pointer sum in BST

Reverse inorder traversal problems

ğŸ§  Final Interview Recap
Concept	Key Takeaway
Traversal Type	Inorder gives sorted order
Optimization	Use stack to simulate recursion lazily
Space Reduction	O(h) using stack, vs O(N) for full traversal
Amortized Time	Each node pushed & popped once â†’ O(1) avg per op
Patterns	Iterative inorder, iterator design, amortized analysis

Would you like me to extend this to show how to use this iterator to find the kth smallest element (a common follow-up asked in Nutanix and Google interviews)?







You said:
yes plese


ChatGPT said:
Perfect ğŸ”¥ â€” this is exactly the kind of follow-up that top interviewers (like at Nutanix, Google, or Uber) love after BST Iterator.

Theyâ€™ll often say something like:

â€œCool, youâ€™ve built a BST Iterator. Now, how can you use it to find the k-th smallest element in a BST efficiently?â€

Letâ€™s walk through this follow-up in full interview-style format ğŸ‘‡

ğŸ§  Problem Recap: Kth Smallest Element in a BST
Given the root of a Binary Search Tree (BST) and an integer k, return the k-th smallest value (1-indexed) of all the values of the nodes in the tree.

Leetcode 230. Kth Smallest Element in a BST

ğŸ—£ï¸ Interview Dialogue
Interviewer:
Youâ€™ve just implemented a BST Iterator that gives the next smallest element in order. Can you now get the k-th smallest?

You:
Yes!
Since the iterator already returns elements in ascending order, the k-th call to next() will give the k-th smallest element.

ğŸ§© Step 1: Using BSTIterator (Already Built)
Weâ€™ll reuse the BSTIterator class we just created.

Approach
Initialize iterator with the root.

Call next() k times.

The last returned value is our answer.

âœ… Code Using BSTIterator
cpp
Copy code
class BSTIterator {
private:
    stack<TreeNode*> st;
    void pushLeft(TreeNode* node) {
        while (node) {
            st.push(node);
            node = node->left;
        }
    }

public:
    BSTIterator(TreeNode* root) {
        pushLeft(root);
    }

    int next() {
        TreeNode* node = st.top(); st.pop();
        pushLeft(node->right);
        return node->val;
    }

    bool hasNext() {
        return !st.empty();
    }
};

class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        BSTIterator it(root);
        int ans = -1;
        while (k-- > 0 && it.hasNext()) {
            ans = it.next();
        }
        return ans;
    }
};
ğŸ§® Complexity Analysis
Operation	Time Complexity	Space Complexity
kthSmallest()	O(h + k)	O(h)
Explanation	O(h) for first left path push, O(k) for next() calls	stack holds up to height of tree

âœ… Amortized O(1) per next()
âœ… Efficient, lazy traversal
âœ… Doesnâ€™t modify tree

ğŸ” Dry Run Example
BST:

markdown
Copy code
        5
       / \
      3   6
     / \
    2   4
   /
  1
Let k = 3
Inorder = [1, 2, 3, 4, 5, 6] â†’ 3rd smallest = 3

Steps:
Push all left: [5, 3, 2, 1]

next() â†’ 1 (k=2)

next() â†’ 2 (k=1)

next() â†’ 3 (k=0)
âœ… Answer = 3

ğŸ§  Step 2: Direct Iterative (Without Separate Iterator Class)
If the interviewer says:

â€œNice, but can you do it in one function without creating a separate class?â€

You can integrate the same inorder stack logic directly.

Code (Direct Iterative)
cpp
Copy code
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> st;
        TreeNode* curr = root;

        while (true) {
            // Go left as much as possible
            while (curr) {
                st.push(curr);
                curr = curr->left;
            }

            curr = st.top(); st.pop();
            k--; // visiting one node in inorder
            if (k == 0) return curr->val; // found k-th smallest

            curr = curr->right;
        }
    }
};
âœ… Same logic
âœ… Less code
âœ… Ideal if they want a â€œcleaner one-shot functionâ€
âœ… Still O(h + k) time, O(h) space

ğŸ§® Complexity (Both Methods)
Metric	Value
Time Complexity	O(h + k)
Space Complexity	O(h)
Inorder Traversal Type	Lazy (on-demand)
Modification to Tree	None

âš™ï¸ Step 3: If the Interviewer Pushes You Further
Follow-up 1ï¸âƒ£ â€” What if the BST is frequently modified (insert/delete)?
Then our iterator-style traversal wonâ€™t help â€” weâ€™d need a data structure that supports:

Order-statistics (like order_of_key() in PBDS or an augmented tree)

Maintain subtree sizes to get k-th smallest in O(log N)

cpp
Copy code
// Example node augmentation (concept)
struct Node {
    int val;
    Node* left;
    Node* right;
    int size; // count of nodes in subtree
};
Then:

leftSize = size(left subtree)

If k == leftSize + 1 â†’ current node

If k <= leftSize â†’ go left

Else â†’ go right with k = k - leftSize - 1

âœ… This gives O(log N) per query if we maintain sizes on insertion/deletion.

Follow-up 2ï¸âƒ£ â€” What if we need Kth Largest?
You just reverse the traversal:

Go right first (instead of left)

Decrement k as you visit nodes in reverse-inorder

ğŸ§  Pattern Recognition for Revision
Pattern	Explanation
Inorder Traversal â†’ Sorted Order	Directly maps to â€œnext smallestâ€ logic
Lazy Traversal via Stack	Efficient, memory-optimal BST exploration
Iterator Design Pattern	Reusable across BST problems (Two Sum, Kth smallest/largest)
Amortized Analysis	Each node processed once â†’ O(1) avg per call
Augmentation for Dynamic Trees	Maintain subtree sizes for O(logN) queries

ğŸ Final Takeaway
Level	Approach	Time	Space	Comment
Easy	Recursive Inorder with vector	O(N)	O(N)	Simple but not lazy
Medium	Iterative Stack (One-shot function)	O(h + k)	O(h)	Efficient
Hard	Iterator Class	O(h + k)	O(h)	Elegant, reusable
Advanced	Augmented BST	O(logN)	O(1) extra	For dynamic updates

Would you like me to continue the next follow-up they usually ask after this â€”
ğŸ‘‰ â€œFind if there exist two elements in a BST such that their sum equals target (using two BST iterators)â€ â€” it directly extends from this iterator concept and is a Nutanix/Google L3+ level variant.







You said:
yes


ChatGPT said:
Perfect! This is the classic follow-up interview problem that extends the BST iterator concept into a two-pointer technique on a BST. This is often asked in Nutanix, Uber, and Google interviews as a medium-to-hard problem.

ğŸ§  Problem Statement
Given a BST and a target k, determine if there exist two elements in the BST whose sum equals k.

Constraints:

Use O(h) space (stack-based), not O(N).

BST property must be leveraged.

Leetcode variant: 653. Two Sum IV - Input is a BST

ğŸ—£ï¸ Interview Dialogue
Interviewer:
Youâ€™ve built a BST iterator. How can you efficiently check if two numbers sum up to a target?

Candidate:
We can mimic the two-pointer approach used in arrays:

Use one iterator for next smallest (inorder).

Use another iterator for next largest (reverse inorder).

Move the pointers toward each other to find if the sum equals k.

ğŸ§© Step 1: Implement Reverse Iterator
We already have BSTIterator for inorder (ascending).
We need a reverse iterator (descending):

cpp
Copy code
class BSTReverseIterator {
private:
    stack<TreeNode*> st;

    void pushRight(TreeNode* node) {
        while (node) {
            st.push(node);
            node = node->right;
        }
    }

public:
    BSTReverseIterator(TreeNode* root) {
        pushRight(root);
    }

    int next() {
        TreeNode* node = st.top(); st.pop();
        pushRight(node->left);
        return node->val;
    }

    bool hasNext() {
        return !st.empty();
    }
};
âœ… Push rightmost nodes initially, then traverse in reverse in-order.

ğŸ§© Step 2: Two-Pointer Approach on BST
cpp
Copy code
class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        if (!root) return false;

        BSTIterator left(root);           // ascending
        BSTReverseIterator right(root);   // descending

        int l = left.next();
        int r = right.next();

        while (l < r) {
            int sum = l + r;
            if (sum == k) return true;
            else if (sum < k) l = left.next();
            else r = right.next();
        }
        return false;
    }
};
ğŸ§® Complexity Analysis
Metric	Value
Time Complexity	O(N) worst case (each node visited once)
Space Complexity	O(h) (two stacks of height h)
Traversal Type	Lazy, O(1) amortized per iterator

ğŸ” Dry Run Example
BST:

markdown
Copy code
        5
       / \
      3   6
     / \   \
    2   4   7
Target k = 9

Ascending iterator â†’ 2

Descending iterator â†’ 7

2 + 7 = 9 âœ… Found!

If not found, pointers move inward until they meet.

ğŸ§  Key Interview Takeaways
Concept	Takeaway
Two iterators = Two pointers	Works like array two-pointer but on BST using O(h) space
Lazy traversal	Only process nodes on demand
Amortized O(1)	Each node pushed/popped once per iterator
Stack height = h	Memory-efficient for large BSTs
Reusability	Can be extended to k-th smallest/largest, range queries

ğŸ”„ Follow-up Variants
Count pairs with sum = k â†’ iterate both ends and count instead of returning bool

Find all unique pairs â†’ use same two-pointer approach

BST with duplicates â†’ handle equality carefully (l != r)

Dynamic BST â†’ augment tree with size/count for efficient pair sum queries

âš¡ Pattern Recognition
Inorder â†’ sorted ascending

Reverse inorder â†’ sorted descending

Two-pointer technique applies perfectly on BST iterators

Lazy stack-based traversal â†’ O(h) memory instead of O(N)

If you want, I can make a fully connected â€œBST Iterator + Kth Smallest + Two Sum BSTâ€ cheat sheet showing all three linked together with code templates and dry run examples, which is exactly how interviewers at Nutanix/FAANG will ask consecutive questions.

Do you want me to do that next?







You said:
yes please


ChatGPT said:
Perfect! Letâ€™s make a complete BST Iterator Cheat Sheet â€” a single connected guide covering:

BST Iterator (next smallest)

Kth Smallest Element using Iterator

Two Sum in BST using two iterators

This will be interview-ready, with code templates, dry runs, and complexity analysis. Think of it as your Nutanix/FAANG BST toolkit.

ğŸŒ³ BST Iterator Cheat Sheet
1ï¸âƒ£ BST Iterator â€“ Next Smallest Element
Problem: Traverse BST in ascending order lazily.

âœ… Key Idea
Use a stack to simulate recursive in-order traversal

Push all left nodes first

next() pops the top and pushes left path of right child

Code Template
cpp
Copy code
class BSTIterator {
private:
    stack<TreeNode*> st;

    void pushLeft(TreeNode* node) {
        while (node) {
            st.push(node);
            node = node->left;
        }
    }

public:
    BSTIterator(TreeNode* root) {
        pushLeft(root);
    }

    int next() {
        TreeNode* node = st.top(); st.pop();
        pushLeft(node->right);
        return node->val;
    }

    bool hasNext() {
        return !st.empty();
    }
};
Complexity:

next(): Amortized O(1)

hasNext(): O(1)

Space: O(h)

Dry Run:

perl
Copy code
BST:      7
         / \
        3   15
           /  \
          9   20

Stack after init: [7,3] (top 3)
next() -> 3
next() -> 7, push 15 and its left 9 -> Stack: [15,9]
next() -> 9
...
2ï¸âƒ£ Kth Smallest Element in BST Using Iterator
Problem: Return kth smallest element (1-indexed).

Key Idea
Reuse BSTIterator

Call next() k times â†’ last value is answer

Code Template
cpp
Copy code
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        BSTIterator it(root);
        int ans = -1;
        while (k-- > 0 && it.hasNext()) {
            ans = it.next();
        }
        return ans;
    }
};
Complexity:

Time: O(h + k)

Space: O(h)

Dry Run:

makefile
Copy code
BST:      5
         / \
        3   6
       / \
      2   4
     /
    1

k = 3, inorder = [1,2,3,4,5,6]
next() -> 1,2,3 â†’ answer = 3
Optional: One-shot Iterative Function (without separate iterator class)
cpp
Copy code
int kthSmallest(TreeNode* root, int k) {
    stack<TreeNode*> st;
    TreeNode* curr = root;
    while (true) {
        while (curr) { st.push(curr); curr = curr->left; }
        curr = st.top(); st.pop();
        if (--k == 0) return curr->val;
        curr = curr->right;
    }
}
3ï¸âƒ£ Two Sum in BST (Sum = Target) Using Two Iterators
Problem: Determine if two BST nodes sum up to target k

Key Idea
Use two iterators:

Inorder (ascending) â†’ left

Reverse Inorder (descending) â†’ right

Move pointers like two-pointer in sorted array

Reverse Iterator Template
cpp
Copy code
class BSTReverseIterator {
private:
    stack<TreeNode*> st;

    void pushRight(TreeNode* node) {
        while (node) {
            st.push(node);
            node = node->right;
        }
    }

public:
    BSTReverseIterator(TreeNode* root) {
        pushRight(root);
    }

    int next() {
        TreeNode* node = st.top(); st.pop();
        pushRight(node->left);
        return node->val;
    }

    bool hasNext() {
        return !st.empty();
    }
};
Two-pointer Implementation
cpp
Copy code
class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        if (!root) return false;

        BSTIterator left(root);           // ascending
        BSTReverseIterator right(root);   // descending

        int l = left.next();
        int r = right.next();

        while (l < r) {
            int sum = l + r;
            if (sum == k) return true;
            else if (sum < k) l = left.next();
            else r = right.next();
        }
        return false;
    }
};
Complexity:

Time: O(N) worst case (each node visited once)

Space: O(h) (two stacks)

Dry Run:

makefile
Copy code
BST:      5
         / \
        3   6
       / \   \
      2   4   7

k = 9
l=2 (smallest), r=7 (largest)
2+7=9 âœ… Found
ğŸ”‘ Summary: BST Iterator Pattern
Concept	Use Case
BSTIterator	Next smallest (in-order traversal)
Reverse Iterator	Next largest (reverse in-order traversal)
Kth Smallest	Use iterator k times
Two Sum in BST	Two iterators like two pointers
Lazy traversal	O(h) memory instead of O(N)
Amortized O(1)	Each node visited once

ğŸ† Interview Tips
Always explain stack simulation of recursion first.

Dry run small BST examples with next() to convince the interviewer.

Mention amortized complexity â€” shows deeper understanding.

Show variants: kth largest, all pairs sum, dynamic BST (augmentation).

Be ready to write both iterator-based and one-shot function solutions.

If you want, I can also make a visual diagram with stacks for all three scenarios so you can memorize the traversal flow in under 2 minutes for interviews â€” super handy for Nutanix/OA/onsite prep.

Do you want me to do that next?







You said:
yes


ChatGPT said:
Perfect! Letâ€™s make a visual cheat sheet for BST Iterator, Kth Smallest, and Two Sum in BST â€” showing stack states and traversal flow step by step. This is exactly what interviewers love when you explain your thought process on the whiteboard.

ğŸŒ³ BST Iterator Visual Guide
Weâ€™ll use this BST for all examples:

markdown
Copy code
        5
       / \
      3   6
     / \
    2   4
   /
  1
1ï¸âƒ£ BST Iterator â€“ Next Smallest (Inorder)
Goal: Traverse BST in ascending order using a stack (lazy traversal).

Step 0: Initialize
Push all left nodes from root: 5 â†’ 3 â†’ 2 â†’ 1

Stack (top â†’ bottom): [1,2,3,5]

Step 1: next() â†’ 1
Pop 1 â†’ no right child

Stack after pop: [2,3,5]

Output: 1 âœ…

Step 2: next() â†’ 2
Pop 2 â†’ push left path of right child (2 has no right)

Stack: [3,5]

Output: 2 âœ…

Step 3: next() â†’ 3
Pop 3 â†’ push left path of right child (4)

Stack: [4,5]

Output: 3 âœ…

Step 4: next() â†’ 4
Pop 4 â†’ no right child

Stack: [5]

Output: 4 âœ…

Step 5: next() â†’ 5
Pop 5 â†’ push left path of right child (6)

Stack: [6]

Output: 5 âœ…

Step 6: next() â†’ 6
Pop 6 â†’ no right child

Stack: []

Output: 6 âœ…

Traversal complete: [1,2,3,4,5,6]

âœ… This confirms iterator works step by step.

2ï¸âƒ£ Kth Smallest Element (Using BST Iterator)
Example: k = 3

Call next() 3 times: 1 â†’ 2 â†’ 3

âœ… Answer = 3

Stack trace per call:

[1,2,3,5] â†’ pop 1 â†’ [2,3,5]

[2,3,5] â†’ pop 2 â†’ [3,5]

[3,5] â†’ pop 3 â†’ [4,5]

Observation: Stack is always top = next smallest.

3ï¸âƒ£ Two Sum in BST (Two Iterators)
Goal: Find two elements summing to target = 9

Iterators
Left iterator (ascending): next smallest

Right iterator (descending): next largest

Step 0: Initialize
Left stack: [1,2,3,5] â†’ top = 1

Right stack: [6,5] â†’ top = 6

Step 1: Compare sum
l = 1, r = 6 â†’ sum = 7 < 9 â†’ move left pointer

Call next() on left â†’ l = 2

Left stack after pop: [2,3,5] â†’ pop 2 â†’ [3,5]

Step 2: Compare sum
l = 2, r = 6 â†’ sum = 8 < 9 â†’ move left pointer

Call next() on left â†’ l = 3

Left stack: [4,5]

Step 3: Compare sum
l = 3, r = 6 â†’ sum = 9 âœ… Found

Observation: Two iterators mimic two-pointer technique on array

Left iterator always points to next smallest

Right iterator always points to next largest

Move pointers based on sum comparison

ğŸ¯ Quick Memory Tips
Task	Stack Init	Stack Top	Pointer Moves
Next Smallest	Push all left from root	Smallest	Pop top, push left path of right child
Kth Smallest	Same as iterator	Kth pop	Pop k times
Two Sum	Left: push all left, Right: push all right	L: smallest, R: largest	If sum < target â†’ next left, else â†’ next right

âœ… Bonus Visual Tips for Whiteboard
Draw stack at each step instead of the whole tree.

Show top of stack clearly â†’ next node to output.

For two sum: draw two stacks side by side with top pointers labeled.

Explain lazy traversal â€” nodes only pushed when needed.

If you want, I can make a single-page PDF-style cheat sheet combining:

All three scenarios

Stack diagrams

Dry runs

Code templates

This will be your interview-ready visual BST toolkit to memorize in 5 minutes.

Do you want me to create that next?







You said:
yes


ChatGPT said:
Perfect! Letâ€™s create a single-page, interview-ready BST toolkit cheat sheet â€” combining BST Iterator, Kth Smallest, and Two Sum in BST, with code templates, dry runs, and stack diagrams so you can memorize it in 5 minutes. Iâ€™ll format it like a PDF/page style you could print or keep as notes.

ğŸŒ³ BST Interview Cheat Sheet (Iterator + Kth Smallest + Two Sum)
1ï¸âƒ£ BST Iterator â€“ Next Smallest
Problem: Return elements in ascending order (lazy traversal).

Key Idea
Stack simulates recursion

Push all left nodes first

next() â†’ pop top, push left path of right child

Code Template
cpp
Copy code
class BSTIterator {
private:
    stack<TreeNode*> st;
    void pushLeft(TreeNode* node) {
        while (node) { st.push(node); node = node->left; }
    }
public:
    BSTIterator(TreeNode* root) { pushLeft(root); }
    int next() {
        TreeNode* node = st.top(); st.pop();
        pushLeft(node->right);
        return node->val;
    }
    bool hasNext() { return !st.empty(); }
};
Complexity:

next(): Amortized O(1)

hasNext(): O(1)

Space: O(h)

Dry Run (BST Example):

perl
Copy code
        5
       / \
      3   6
     / \
    2   4
   /
  1

Stack Init: [1,2,3,5] top=1
next() â†’ 1 â†’ stack: [2,3,5]
next() â†’ 2 â†’ stack: [3,5]
next() â†’ 3 â†’ push 4 â†’ stack: [4,5]
next() â†’ 4 â†’ stack: [5]
next() â†’ 5 â†’ push 6 â†’ stack: [6]
next() â†’ 6 â†’ stack: []
2ï¸âƒ£ Kth Smallest Element
Problem: Return kth smallest element in BST

Key Idea
Use BSTIterator

Call next() k times â†’ last value is answer

Code Template
cpp
Copy code
int kthSmallest(TreeNode* root, int k) {
    BSTIterator it(root);
    int ans = -1;
    while(k-- > 0 && it.hasNext()) ans = it.next();
    return ans;
}
Dry Run: k = 3

next() â†’ 1 â†’ 2 â†’ 3 âœ… Answer = 3

Stack states: [1,2,3,5] â†’ [2,3,5] â†’ [3,5] â†’ [4,5]

Complexity: O(h+k) time, O(h) space

3ï¸âƒ£ Two Sum in BST (Target Sum)
Problem: Determine if there exist two nodes summing to k

Key Idea
Use two iterators:

Inorder â†’ ascending (left)

Reverse Inorder â†’ descending (right)

Move pointers like two-pointer in sorted array

Reverse Iterator Template
cpp
Copy code
class BSTReverseIterator {
private:
    stack<TreeNode*> st;
    void pushRight(TreeNode* node) {
        while(node) { st.push(node); node=node->right; }
    }
public:
    BSTReverseIterator(TreeNode* root) { pushRight(root); }
    int next() {
        TreeNode* node = st.top(); st.pop();
        pushRight(node->left);
        return node->val;
    }
    bool hasNext() { return !st.empty(); }
};
Two-pointer Implementation
cpp
Copy code
bool findTarget(TreeNode* root, int k) {
    BSTIterator left(root);
    BSTReverseIterator right(root);
    int l = left.next();
    int r = right.next();
    while(l < r) {
        int sum = l+r;
        if(sum==k) return true;
        else if(sum<k) l = left.next();
        else r = right.next();
    }
    return false;
}
Dry Run Example:

BST: same as above, k=9

left top=1, right top=6 â†’ sum=7 < 9 â†’ next left

left=2, right=6 â†’ sum=8 < 9 â†’ next left

left=3, right=6 â†’ sum=9 âœ… Found

Complexity: O(N) time worst case, O(h) space

ğŸ§© Stack Diagram Summary
Task	Stack Init	Top	Move
Next Smallest	Push all left from root	Smallest	Pop top, push left path of right child
Kth Smallest	Same as iterator	Kth pop	Pop k times
Two Sum	Left push all left, Right push all right	L=smallest, R=largest	If sum<target â†’ next left, else â†’ next right

âœ… Interview Tips
Always draw stack instead of whole tree on whiteboard.

Explain lazy traversal (nodes processed on demand).

Highlight amortized O(1) next() and O(h) space.

Mention variants:

Kth largest â†’ reverse iterator

All pairs sum â†’ extend two-pointer approach

Dynamic BST â†’ augment tree with subtree sizes

Show dry run with stack states for clarity.

This sheet covers all BST iterator patterns in one page â€” ready for Nutanix/FAANG onsite prep.
