this is exactly the right next problem!
Letâ€™s now go through Leetcode 450 â€” Delete Node in a Binary Search Tree in Nutanix / Google interview format â€” full reasoning, dry runs, debugging dialogue, and all patterns you must remember.

ğŸŒ³ 450. Delete Node in a BST
Difficulty: Medium
Topic: BST (Binary Search Tree), Recursion
Asked at: Google, Nutanix, Visa, Uber, Microsoft

ğŸ§  Problem Statement
Given the root of a Binary Search Tree (BST) and a key, delete the node with that value while maintaining BST properties.
Return the modified root.

âš™ï¸ BST Property Reminder
For any node:

css
Copy code
Left subtree < node < Right subtree
ğŸ§© Example
Input:

ini
Copy code
root = [5,3,6,2,4,null,7]
key = 3
Tree:

markdown
Copy code
      5
     / \
    3   6
   / \   \
  2   4   7
After deleting 3:

markdown
Copy code
      5
     / \
    4   6
   /     \
  2       7
ğŸ§‘â€ğŸ’» INTERVIEW FORMAT
ğŸ—£ï¸ Interviewerâ€“Candidate Dialogue
Interviewer:
Alright Rahul, we just saw how to insert a value into a BST.
Now, can you explain how youâ€™d delete a node from it?

Candidate:
Sure!
Deletion in a BST depends on how many children the node has.
We can have three cases:

ğŸ¯ Step 1: Conceptual Discussion (Core Cases)
Case	Description	What to Do
1ï¸âƒ£ Node not found	key < root or > root	Traverse recursively
2ï¸âƒ£ Node has no child (leaf)	Delete directly	Return NULL
3ï¸âƒ£ Node has one child	Return non-null child	Replace node with its child
4ï¸âƒ£ Node has two children	Replace with inorder successor	Find minimum node in right subtree

ğŸ§© Step 2: Recursive Solution
ğŸ” Recurrence Relation:
sql
Copy code
if key < root->val:
    root->left = delete(root->left, key)
elif key > root->val:
    root->right = delete(root->right, key)
else:
    // Node found
    if no left: return right
    if no right: return left
    root->val = inorderSuccessor(root->right)
    root->right = delete(root->right, root->val)
return root
ğŸ’» C++ Code (Recursive â€” Standard Template)
cpp
Copy code
// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return NULL;

        // Step 1: Traverse left or right based on BST property
        if (key < root->val) {
            root->left = deleteNode(root->left, key);
        }
        else if (key > root->val) {
            root->right = deleteNode(root->right, key);
        }
        else {
            // Step 2: Node found â€” handle 3 cases

            // Case 1: No child (leaf node)
            if (!root->left && !root->right) {
                delete root;
                return NULL;
            }

            // Case 2: One child
            if (!root->left) {
                TreeNode* temp = root->right;
                delete root;
                return temp;
            }
            else if (!root->right) {
                TreeNode* temp = root->left;
                delete root;
                return temp;
            }

            // Case 3: Two children
            TreeNode* successor = findMin(root->right); // inorder successor
            root->val = successor->val;
            root->right = deleteNode(root->right, successor->val);
        }
        return root;
    }

private:
    // Utility: find smallest node in a subtree
    TreeNode* findMin(TreeNode* node) {
        while (node->left) node = node->left;
        return node;
    }
};
ğŸ” Step 3: Dry Run Example
Example Input:
sql
Copy code
Delete 3 from:
      5
     / \
    3   6
   / \   \
  2   4   7
Step-by-step:

1ï¸âƒ£ key = 3 < 5 â†’ go left
2ï¸âƒ£ Found node 3

Node 3 has two children (2, 4)

Find inorder successor â†’ smallest in right subtree = 4

Replace 3 â†’ 4

Delete node 4 from right subtree

Final Tree:

markdown
Copy code
      5
     / \
    4   6
   /     \
  2       7
âœ… Works perfectly.

ğŸ§® Step 4: Time and Space Complexity
Operation	Complexity	Explanation
Time	O(h)	Traverses height of BST (O(log N) for balanced, O(N) for skewed)
Space	O(h)	Recursion call stack

ğŸ§  Step 5: Iterative Version (for Space Optimization)
Interviewer:
Can you do it iteratively to save stack space?

Candidate:
Yes, but deletion is trickier iteratively â€” weâ€™d need parent pointers to reconnect subtrees. Recursive version is more elegant, so thatâ€™s usually preferred unless explicitly asked.

Still, hereâ€™s a version outline:

Find node & parent iteratively.

Reconnect parent->child based on cases.

Handle edge cases when deleting root.

ğŸ’¡ Usually not preferred in interviews unless they insist on non-recursive.

ğŸ§© Pattern Recognition & Interview Tricks
Pattern	Description
Insert vs Delete	Both traverse path using BST property, but delete has 3 structural cases.
Successor Concept	Always smallest node in right subtree (used for deletion & BST iterator).
Common Trick	For two children: replace value â†’ delete successor.
Template Memory	if(val<root->val) left=delete(); else if(val>root->val) right=delete(); else {...}

ğŸš€ Follow-up / Advanced Interview Questions
Q: Can we use inorder predecessor instead of successor?
A: Yes â€” use largest node in left subtree instead of smallest in right.

Q: How do we maintain balance after deletion?
A: Thatâ€™s handled in AVL / Red-Black Trees with rotations after deletion.

Q: What if duplicates exist?
A: Define a rule â€” usually delete one occurrence and maintain BST property consistently.

ğŸ§© Related & Revision-Chain Questions (Common in Nutanix / Google)
701. Insert into BST âœ…

450. Delete Node in BST â† current

700. Search in BST

98. Validate BST

235. Lowest Common Ancestor in BST

530 / 783. Minimum Absolute Difference in BST

173. BST Iterator (Inorder successor pattern)

ğŸ’¬ Final Takeaway
ğŸ’¡ Insertion builds structure, Deletion maintains it.
Think like: â€œFind node â†’ Identify case â†’ Adjust pointers â†’ Maintain BST property.â€
The recursive template is key â€” memorize that form.
