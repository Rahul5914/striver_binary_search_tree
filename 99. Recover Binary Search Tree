Let’s tackle 99. Recover Binary Search Tree in full interview-style, step by step. I’ll cover the problem understanding, approaches, code templates, and common pitfalls, just like Nutanix or FAANG interviews.

Problem Statement
Two elements of a BST are swapped by mistake. Recover the tree without changing its structure.
You need to fix the BST in-place.

Example:

yaml
Copy code
Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]

Explanation: 1 and 3 are swapped.
Step 1: Clarify
Are there always exactly 2 nodes swapped? ✅ Yes.

Can we use extra space? ✅ Can, but optimized O(1) space preferred.

Do we need to return the tree? ✅ Modify in-place.

Key observation:

Inorder traversal of BST is sorted.

Swapping two nodes breaks the sorted order.

Step 2: Brute Force / Simple Approach
Idea:

Do inorder traversal, store nodes in a list.

Identify the two nodes that are out of order.

Swap their values.

Time Complexity: O(n)
Space Complexity: O(n)

Code:

cpp
Copy code
class Solution {
public:
    vector<TreeNode*> nodes;
    
    void inorder(TreeNode* root) {
        if (!root) return;
        inorder(root->left);
        nodes.push_back(root);
        inorder(root->right);
    }
    
    void recoverTree(TreeNode* root) {
        inorder(root);
        TreeNode* first = nullptr;
        TreeNode* second = nullptr;
        
        for (int i = 0; i < nodes.size() - 1; i++) {
            if (nodes[i]->val > nodes[i+1]->val) {
                if (!first) first = nodes[i];
                second = nodes[i+1];
            }
        }
        swap(first->val, second->val);
    }
};
✅ Interview Tip:

Explain: “We are exploiting the sorted property of inorder traversal.”

Step 3: Optimized Approach (O(1) Space)
Idea:

Use Morris Traversal (threaded inorder traversal) to achieve constant space.

Keep track of previous node while traversing.

Detect the two swapped nodes as follows:

First violation: prev > current → first = prev, second = current

Second violation: prev > current → second = current

Finally, swap the two nodes’ values.

Code:

cpp
Copy code
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;
        TreeNode* curr = root;
        
        while (curr) {
            if (!curr->left) {
                // Check violation
                if (prev && prev->val > curr->val) {
                    if (!first) first = prev;
                    second = curr;
                }
                prev = curr;
                curr = curr->right;
            } else {
                // Find predecessor
                TreeNode* pred = curr->left;
                while (pred->right && pred->right != curr)
                    pred = pred->right;
                
                if (!pred->right) {
                    pred->right = curr;
                    curr = curr->left;
                } else {
                    pred->right = nullptr;
                    // Check violation
                    if (prev && prev->val > curr->val) {
                        if (!first) first = prev;
                        second = curr;
                    }
                    prev = curr;
                    curr = curr->right;
                }
            }
        }
        swap(first->val, second->val);
    }
};
✅ Key Points for Interview:

Detecting violations: prev > current in inorder.

Handling two swapped nodes: Could be adjacent or non-adjacent in inorder.

Space Optimization: O(1) using Morris traversal.

Dry Run: Use [3,1,4,null,null,2] to check both adjacent and non-adjacent swaps.

Step 4: Recap / Interview Strategy
Observe inorder property (sorted BST).

Brute force: store nodes → O(n) space.

Optimized: Morris traversal → O(1) space.

Identify first and second nodes by violation detection.

Swap values → tree recovered.

Edge cases: adjacent vs non-adjacent nodes swapped.

If you want, I can draw a visual dry run diagram showing how Morris traversal detects swapped nodes, which makes it very clear in an interview setting.

Do you want me to do that?







You said:
yes


ChatGPT said:
Perfect! Let’s visualize Recover Binary Search Tree with a Morris Traversal dry run diagram — this is exactly how you’d explain it in an interview.

Example Tree
Suppose we have a BST:

markdown
Copy code
      3
     / \
    1   4
       /
      2
Here, nodes 2 and 3 are swapped. Correct BST should be:

markdown
Copy code
      2
     / \
    1   4
       /
      3
Step 1: Inorder Traversal (should be sorted)
Normal inorder (left → root → right) gives: 1, 3, 2, 4

Correct inorder should be: 1, 2, 3, 4

Observation:

First violation: 3 > 2

So:

first = 3 (prev node)

second = 2 (current node)

✅ Only one violation in this example because the swapped nodes are non-adjacent in inorder.

Step 2: Morris Traversal Concept
Morris Traversal avoids recursion/stack:

Start at root (curr = 3)

Go to left child until leftmost (1)

For each node:

If left exists → find predecessor → make thread to current

If left doesn’t exist → visit node → move right

Tracking prev node helps detect violation.

Step 3: Step-by-Step Morris Dry Run
Step	curr	prev	Action
1	3	null	Left exists → find predecessor (2), make thread 2->right = 3, move curr = 1
2	1	null	Left null → visit node, prev = 1, move right → null → follow thread back to 3
3	3	1	Check violation: 1 < 3 ✅ OK, move prev = 3, move curr = 2 (threaded right)
4	2	3	Violation detected: 3 > 2 → first = 3, second = 2, prev = 2, move curr = 4
5	4	2	Check violation: 2 < 4 ✅ OK, prev = 4, curr = null → traversal ends

Step 4: Swap Values
Swap first.val and second.val → 3 ↔ 2

Tree is now recovered:

markdown
Copy code
      2
     / \
    1   4
       /
      3
✅ Correct BST.

Step 5: Key Interview Points
Inorder traversal of BST is sorted → easy way to detect swapped nodes.

Two swapped nodes → can be adjacent or non-adjacent in inorder.

Morris traversal → O(1) space, perfect for large BSTs.

Always keep prev pointer to detect violations.

Swap only values, tree structure remains unchanged.

If you want, I can also make a small visual diagram showing the threads and prev pointer moving during Morris traversal — it makes it crystal clear for interviews.

Do you want me to do that too?







You said:
yes


ChatGPT said:
Perfect! Let’s create a visual diagram of Morris Traversal for Recover Binary Search Tree showing threads and the prev pointer movement.

We’ll use the same swapped BST:

markdown
Copy code
      3
     / \
    1   4
       /
      2
Step 1: Initial Tree
markdown
Copy code
      3
     / \
    1   4
       /
      2
Swapped nodes: 3 and 2
Goal: Detect via inorder traversal (1, 3, 2, 4)

Step 2: Add Morris Threads
Morris Traversal creates temporary right pointers from predecessor to current:

Node 3 has left child 1 → predecessor = 1 → thread: 1->right = 3

Node 4 has left child 2 → predecessor = 2 → thread: 2->right = 4

Diagram with threads (dashed lines):

yaml
Copy code
      3
     / \
    1───┐
        |
        v
        3
       / \
      1   4
         /
        2───┐
            |
            v
            4
Dashed lines indicate temporary threads back to parent.

Step 3: Step-by-Step Traversal with prev
Step	curr	prev	Action / Violation
1	3	null	Go left → 1
2	1	null	Left null → visit 1, prev = 1, follow thread → 3
3	3	1	1 < 3 ✅ OK, prev = 3, move to left of 4 → 2
4	2	3	Violation: 3 > 2 → first = 3, second = 2, prev = 2, follow thread → 4
5	4	2	2 < 4 ✅ OK, prev = 4, traversal ends

Step 4: Swap Values
Swap first.val and second.val → 3 ↔ 2

✅ BST recovered:

markdown
Copy code
      2
     / \
    1   4
       /
      3
Step 5: Key Visual Notes for Interviews
Threads are temporary → restore tree structure when done.

prev pointer detects violations (prev.val > curr.val).

Two cases for swapped nodes:

Adjacent → one violation

Non-adjacent → two violations

Swap only values, not nodes.
