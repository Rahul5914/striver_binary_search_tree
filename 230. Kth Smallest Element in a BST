Leetcode 230. Kth Smallest Element in a BST is a classic Binary Search Tree (BST) question thatâ€™s often asked in Nutanix, Uber, Google, and Visa interviews to test your understanding of BST properties, recursion, and traversal optimization.

Letâ€™s go through this in a real interview-style format, with full dialogue, intuition, dry run, and code (plus all approaches â€” brute force to optimized).

ğŸ¯ Problem Statement

Given the root of a Binary Search Tree and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.

ğŸ§© Example

Input:

      3
     / \
    1   4
     \
      2
k = 1


Output:

1

ğŸ§‘â€ğŸ’¼ Interviewerâ€“Candidate Dialogue

Interviewer: What do you know about the properties of a BST?

Candidate (You):
In a Binary Search Tree (BST), the left subtree of a node contains only nodes with keys less than the nodeâ€™s key, and the right subtree contains only nodes with keys greater than the nodeâ€™s key.
This means that if we inorder traverse (Left â†’ Root â†’ Right) the tree, we get all elements in sorted order.

Interviewer: Great. So how can that help us find the kth smallest element?

You:
We can perform an inorder traversal of the BST and count elements as we go. The moment our count reaches k, weâ€™ve found our answer.

Interviewer: Good. Can you walk me through the approaches and their trade-offs?

ğŸ§  Step 1: Brute Force (Collect all elements)
ğŸªœ Idea

Perform an inorder traversal, store all values in a vector, then return v[k-1].

â±ï¸ Time Complexity

O(N) â€” traverse all nodes
ğŸ’¾ Space: O(N) â€” store all node values

ğŸ’» Code (Brute Force)
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& vals) {
        if (!root) return;
        inorder(root->left, vals);
        vals.push_back(root->val);
        inorder(root->right, vals);
    }

    int kthSmallest(TreeNode* root, int k) {
        vector<int> vals;
        inorder(root, vals);
        return vals[k - 1];
    }
};


âœ… Works fine, but uses extra space and unnecessarily visits all nodes even if we find the kth element early.

ğŸ§  Step 2: Optimized Recursive Inorder (Early Stop)
ğŸªœ Idea

Instead of storing all elements, we maintain:

a counter to track how many nodes weâ€™ve visited

a variable ans to store the kth element once found
Stop traversal immediately when count == k.

ğŸ’» Code (Optimized Recursive)
class Solution {
public:
    int ans = -1;
    int count = 0;

    void inorder(TreeNode* root, int k) {
        if (!root) return;

        inorder(root->left, k);

        count++;
        if (count == k) {
            ans = root->val;
            return;
        }

        inorder(root->right, k);
    }

    int kthSmallest(TreeNode* root, int k) {
        inorder(root, k);
        return ans;
    }
};

â±ï¸ Complexity

Time: O(H + k), where H = height of tree (best-case early stop)

Space: O(H) recursion stack

ğŸ§  Step 3: Iterative Inorder Traversal (Stack-based)

Interviewer: Suppose recursion stack size is an issue. Can you make it iterative?

You:
Yes, we can simulate recursion using a stack.
Push all left nodes, then pop from stack k times â€” the kth popped element is the answer.

ğŸ’» Code (Iterative Stack)
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> st;
        TreeNode* curr = root;

        while (true) {
            // Go to leftmost node
            while (curr) {
                st.push(curr);
                curr = curr->left;
            }

            curr = st.top();
            st.pop();
            if (--k == 0) return curr->val;  // kth node found

            curr = curr->right;
        }
    }
};

âœ… Advantages

No recursion

Early stop when kth element found

Time: O(H + k)

Space: O(H)

ğŸ§  Step 4: Further Optimization (Augmented BST / Order Statistics Tree)

Interviewer (Nutanix-level): Can you do better if you get multiple queries asking for kth smallest repeatedly?

You:
We can augment each node to store the count of nodes in its left subtree (leftCount).
Then, for each query:

If k == leftCount + 1, node is the answer

If k <= leftCount, move left

If k > leftCount + 1, move right with updated k

This makes each query O(H) instead of O(N).

ğŸ’» Code (Augmented Node, conceptual)
struct Node {
    int val;
    Node* left;
    Node* right;
    int leftCount;
};

int kthSmallest(Node* root, int k) {
    while (root) {
        if (root->leftCount + 1 == k)
            return root->val;
        else if (k <= root->leftCount)
            root = root->left;
        else {
            k -= (root->leftCount + 1);
            root = root->right;
        }
    }
    return -1;
}


âš™ï¸ This version is often used in Order Statistic Trees or Segment Trees.

ğŸ§ª Dry Run

Letâ€™s dry run for:

Input: root = [3,1,4,null,2], k = 1


Inorder traversal order: [1, 2, 3, 4]
â†’ The 1st smallest = 1

During iterative process:

Stack push(3), push(1)

pop(1): k=0 â†’ return 1 âœ…

ğŸ§© Pattern Recognition

âœ… Inorder traversal â†’ Sorted order for BST
âœ… Early stopping â†’ reduces runtime
âœ… Augmented node approach â†’ supports multiple kth queries
âœ… Reusable for Kth Largest (reverse inorder)

ğŸ§  Related Follow-ups

Kth Largest Element in BST â†’ Reverse Inorder (Right â†’ Root â†’ Left)

Find Median in BST â†’ Use count of nodes and kth element logic

Kth Smallest in Binary Tree (not BST) â†’ Need min-heap

Design a BST Iterator â†’ (Leetcode 173) uses same iterative inorder logic

ğŸ§© Interviewerâ€™s Takeaway

âœ… Candidate understood BST properties well
âœ… Optimized recursion and iterative versions both clear
âœ… Mentioned Order Statistics Tree â€” shows strong depth
ğŸ’¡ Excellent if you mention use of stack-based iterative version in production systems (safer than recursion)
